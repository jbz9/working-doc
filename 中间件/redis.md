## Redis

https://www.redis.com.cn/redis-interview-questions.html

https://redisson.org/ 分布式锁

https://www.cnblogs.com/xuanyuan/p/13665170.html

### 缓存简介

参考：https://juejin.im/post/6883650497975320589

[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#%E7%BC%93%E5%AD%98](https://github.com/CyC2018/CS-Notes/blob/master/notes/缓存.md#缓存)

**命中率**

请求能够从缓存中拿到数据，就是命中，缓存命中率越高，即缓存的效率越高

**最大空间**

缓存往往存在于内存当中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。

### 缓存分类

本地缓存、分布式缓存、多级缓存

* **本地缓存**：缓存在JVM中，一般用Map实现，缺点是内存比较小，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。优点是,没有远程交互，性能比较好
* **分布式缓存**：一般用redis，优点是：容易水平拓展，缺点是：多了远程交互，性能不如本地缓存
* **多级缓存：使用本地+分布式缓存**，本地缓存放访问频率最高的数据，其他的热点数据放在分布式缓存中。

**本地缓存**

使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。

**分布式缓存**
使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。

相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，**而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。**

### 数据结构

**一共5种数据结构，字符串、列表（list）、Hash、Set（无序集合）、Zset（有序集合）;以key、value形式进行存储，key的类型只能是String**

| 数据类型 | 可以存储的值           | 介绍                                                         |
| -------- | ---------------------- | ------------------------------------------------------------ |
| String   | 字符串、整数或者浮点数 | 动态字符串，可以修改                                         |
| List     | 列表                   | 类似linkedList，是双向链表结构，插入、删除很快，查询慢       |
| Set      | 无序集合               | 类似HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL |
| Hash     | 包含键值对的无序散列表 | 类型HashMap，是数组+链表结构                                 |
| ZSet     | 有序集合               | 类似于 Java 中 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。 |

#### 示例

```shell
1、字符串
本机:0>set 1 "小明"
"OK"
本机:0>get 1
//同时设置多组数据，原子操作，要么都成功，要么都设置失败
本机:0>mset 1 "小米" 2 "小红"
"OK"
本机:0>get 1
"小米"
本机:0>get 2
"小红"
本机:0>del 1
"1"
//将指定的值追加到key末尾，若key不存在，则创建并赋值，返回追加后的字符串长度
本机:0>append 1 1
"7"
本机:0>get 1
"小明1"
本机:0>
//查看剩余的生存时间，-1 表示永久存在， -2表示不存在，时间秒
本机:0>ttl 1
"-1"
本机:0>set 1 "小米" ex 10
"OK"
//移除指定key的生存时间，成功返回1，若key不存在或不存在生存时间时返回0
本机:0>persist 1
"1"
  
**全局key操作，对redis的五个数据类型都适用的命令**
rename key newkey    改名
当key和newkey相同或者key不存在时返回一个错误，当newkey已存在时则会覆盖
本机:0>rename 1 2
"OK"
//查看所有的key
本机:0>keys id_*
 1)  "id_1"
 2)  "id_2"
本机:0>keys *
 1)  "id_1"
 2)  "2"
 3)  "id_2"
本机:0>exists 2 查看KEY 是否存在
"1"
本机:0>type 2  查看key的类型
"string"
本机:0>expire 2 1000 设置key的过期时间
"1"
本机:0>persist 2 移除过期时间
"1"
 
2、list列表，是一个字符串列表，可以在列表头部或尾部添加/删除数据
添加数据：
rpush key value [value…]   在尾部添加数据，右边添加
lpush key value [value…]   在头部添加数据
本机:0>rpush name "小米" "小明" "小红"
"3"
本机:0>rpush name "小李"
"4"
本机:0>lindex name 0 查看某一条数据
"小米"
本机:0>lrange name 0 -1 查看列表的所有数据
 1)  "小米"
 2)  "小明"
 3)  "小红"
 4)  "小李"
本机:0>lrange name 0 1 查询一段数据
 1)  "小米"
 2)  "小明"
本机:0>llen name 列表长度
"4"
修改数据：lset key index value
本机:0>lset name 0 "你好" 指定索引，修改列表数据
"OK"
本机:0>lindex name 0
"你好
删除数据：
lpop key    删除左边第一个 头部
rpop key    删除右边第一个

3、Set集合 元素为String类型，无序、不重复
//sadd key member [member...]     增加元素
本机:0>sadd id "1" "2" "3"
"3"
本机:0>scard id 查询元素个数
"3"
本机:0>smembers id 查询所有数据
 1)  "1"
 2)  "2"
 3)  "3"
sismember key member 
本机:0>sismember id "啊啊" 断集合存在某个值
"0"
本机:0>srem id 1 2 删除集合中的元素
"1"
删除 del key

4、Hash类型
是一个键值(key=>value)对集合。是string 类型的 field 和 value 的映射表
     user       　　　　      { name:juhao， 　　          age:18 }
user -> key(键)    　    　name,age ->field(域)    　　 juhao,18 ->value(值)
本机:0>hset user_2 name "小红" id 1 添加数据
"2"
本机:0>hgetall user_2 查询数据
 1)  "name"
 2)  "小红"
 3)  "id"
 4)  "1"
本机:0>hget user_2 name
"小红"
本机:0>hvals user_2 查询所有value
 1)  "小红"
 2)  "1"
本机:0>hkeys user_2  查询所有的key
 1)  "name"
 2)  "id"
 本机:0>hmget user_2 id name 查询多个字段的值
 1)  "1"
 2)  "小红"
本机:0>hlen user_2 查询有几个键值对
"2"

5、zset类型 类似于Set,不同的是Sorted中的每个成员都分配了一个分数（Score）用于对其中的成员进行排序（升序）。zset的成员是唯一的,但分数(score)却可以重复。
zadd key score member[ [score member] ..] 添加、修改
本机:0>zadd top 1 "赵" 2 "钱" 3 "孙"
"3"
本机:0>zrange top 0 -1 查询集合
 1)  "赵"
 2)  "钱"
 3)  "孙"
本机:0>zrangebyscore top 1 2  返回集合中 score 在给定区间的元素
 1)  "赵"
 2)  "钱"
 本机:0>zrem top "赵" 删除元素
"1"
本机:0>zrange top 1 2 删除集合中索引在给定区间的元素
 1)  "孙"
```

#### 使用场景

##### **计数器**

String类型

可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

```java
import redis.clients.jedis.Jedis;

public class RedisCounter {

    private Jedis jedis;

    public RedisCounter() {
        // 连接到本地的 Redis 服务器
        jedis = new Jedis("localhost");
    }

    // 增加计数
    public void incrementCounter(String key) {
        jedis.incr(key);
    }

    // 获取计数
    public long getCounter(String key) {
        return Long.parseLong(jedis.get(key));
    }

    public static void main(String[] args) {
        RedisCounter redisCounter = new RedisCounter();

        // 增加计数器值
        redisCounter.incrementCounter("page_views");
        redisCounter.incrementCounter("page_views");
        redisCounter.incrementCounter("page_views");

        // 获取计数器值
        long pageViews = redisCounter.getCounter("page_views");
        System.out.println("页面浏览次数: " + pageViews);

        // 关闭连接
        redisCounter.jedis.close();
    }
}
```

### 内存过期策略和内存淘汰机制

![17010085573471701008556645.png](https://fastly.jsdelivr.net/gh/jbz9/picture@main/image/17010085573471701008556645.png)

#### 内存过期策略

它是为了处理redis过期的数据，在缓存过期之后，及时的将数据从内存中删除，以减少内存的占用*，Redis是使用定期删除和惰性删除的策略；定时器会定期检查数据集中是否有过期的键，如果发现有过期的键，则会将其删除；惰性删除是在查询数据的时候，先检查键是否过期，如果过期就删除

**Redis使用的策略是：定期、惰性策略**

**定期删除**：定时器会定期检查数据集中是否有过期的键，如果发现有过期的键，则会将其删除。默认100ms

* **优点：****因为是定期删除，所以能够对内存占用控制比较好，避免大量无用数据占用

* **缺点：**不灵活

**惰性删除**：查询数据的时候，先检查键是否过期，如果过期就删除

- **优点：**系统资源占用少，只在查询数据的时候才进行过期检查。
- **缺点：**不及时、延迟性高，如果很长时间内没有请求某个过期的数据，该数据可能一直存在；而且如果这个数据量大的话，最内存也会造成很大压力。

#### 内存淘汰机制

**它是针对内存不足时，redis对数据的处理策略，主要有8种策略，可以通过配置文件进行配置。**

1. **noeviction（不淘汰策略）：**
   - 当内存不足以容纳新写入数据时，新的写入操作会报错。
   - 这是默认的淘汰策略。
2. **allkeys-lru（最近最少使用，全体键）：**
   - 根据键最近被使用的频率进行淘汰。
   - 对所有键进行考虑，选择最近最少使用的键进行淘汰。
3. **volatile-lru（最近最少使用，过期键）：**
   - 仅对设置了过期时间（TTL）的键进行最近最少使用淘汰。
4. **allkeys-random（随机淘汰，全体键）：**
   - 从所有键中随机选择一个进行淘汰。
5. **volatile-random（随机淘汰，过期键）：**
   - 仅对设置了过期时间（TTL）的键进行随机淘汰。
6. **volatile-ttl（根据 TTL 进行淘汰，过期键）：**
   - 对设置了过期时间（TTL）的键，根据 TTL 的值进行淘汰，TTL 越小越容易被淘汰。
7. **volatile-lfu（最不经常使用，过期键）：**
   - 对设置了过期时间（TTL）的键，根据 LFU（Least Frequently Used）算法进行淘汰。
8. **allkeys-lfu（最不经常使用，全体键）：**
   - 根据 LFU 算法对所有键进行淘汰，不考虑过期时间。

### 常见问题

#### 为什么要用redis

它的使用场景比较多比如：缓存、发布订阅消息中间件、分布式锁、计数器这些；**我们主要用做缓存数据库和分布式锁**

#### 为什么redis选用单线程

Redis是存内存操作，它的性能瓶颈是IO而不是CPU，所以多线程并不能带来大的提升；而是使用多线程会带来线程切换的开销。另外Redis还有很多原子性的操作，例如 SETNX（set if not exists），INCR（递增操作），用单线程实现会相对简单

#### 分布式下缓存和数据库一致性问题

#### Redis6.0之前为什么一直不使用多线程？

 Redis主要受限于内存和网络，CPU一般不会成为性能瓶颈，使用单线程，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。Redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。

#### Redis6.0为什么要引入多线程呢？

Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000到100,000 QPS（一台服务器每秒能够响应的查询次数），这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。每秒可以处理50万请求，

但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等。

从Redis自身角度来说，因为读写网络的read/write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:

• 提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式
• 使用多线程充分利用多核，典型的实现比如 Memcached。

协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，redis支持多线程主要就是两个原因：

• 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核
• 多线程任务可以分摊 Redis 同步 IO 读写负荷

#### Redis 有哪些架构模式？讲讲各自的特点

**单机**

特点：简单

问题：

1、内存容量有限 2、处理能力有限 3、无法高可用。

**主从复制**

读写分离，主节点写入数据，从节点从主节点复制数据，数据读取也在从节点读取。

特点：

1、master/slave 角色

2、master/slave 数据相同

3、降低 master 读压力在转交从库

问题：

无法保证高可用

没有解决 master 写的压力

**哨兵模式**

Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：

监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。

提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。

自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。

特点：

1、保证高可用

2、监控各个节点

3、自动故障迁移

缺点：主从模式，切换需要时间丢数据

没有解决 master 写的压力。

**集群模式**

- **特点**：分布式模式，包含多个主节点和从节点，数据分片存储在多个节点上，支持横向扩展。
- **适用场景**：处理大规模数据，提供横向扩展和高可用性。

#### 缓存可能出现的问题

数据不一致的问题、缓存穿透、缓存雪崩

#### 持久化机制

持久化存储，指的是将内存的缓存存在磁盘中，保证redis 挂掉之后再重启数据可以进行恢复，有2种模式：RDB和AOF.

##### RDB（Redis DataBase）持久化

**工作原理**

Redis定期生成快照文件，保存当前数据库的所有键值对的状态。默认情况下，Redis每隔一段时间就会创建一个RDB文件，记录数据库在该时间点的数据快照。

- 优点：

  * 效率高：快照是一个二进制文件，保存了某个时间点上的数据状态，因此恢复数据时很高效。

  - 适用于大规模数据集：在数据集较大的情况下，RDB快照的恢复速度更快。

- 缺点：

  - 可能会有数据丢失：由于是**定期生成**，如果在两次快照之间发生故障，会**导致部分数据的丢失**。
  - 不适合实时持久化：不同于AOF，RDB并非实时持久化，可能在两次快照之间发生故障时，会导致部分数据的丢失

##### AOF（Append Only File）持久化

**工作原理**

AOF 持久化记录每个写操作，以日志的形式保存在 AOF 文件中，这样能够保证Redis 服务器重启时，可以通过重新执行 AOF 文件里的命令来恢复数据库。

- 优点：

  * 实时持久化：AOF持久化是实时的，每个写操作都会立即记录到AOF文件中，因此故障发生时，可能会有较小的数据丢失。

  - 适用于追加写入场景：AOF适用于追加写入场景，对于写入较为频繁的应用，能够提供更好的数据保障。

- 缺点：

  - 文件相对较大：由于AOF文件保存了所有写操作的记录，**相对于RDB文件，AOF文件可能较大**。
  - 恢复速度相对较慢：AOF文件在恢复时，需要逐条重放写操作，**恢复速度相对较慢**。

#### Redis为什么快

QPS每秒10万(每秒查询/请求数)

1. **内存存储：** Redis。将数据存储在内存中，读写速度极快。因为它**避免了磁盘I/O的开销，相比传统数据库的磁盘存储，内存存储能够提供更低的访问延迟。**
2. **单线程模型**：避免多线程之间的锁竞争，降低了线程切换的CPU开销。
3. **非阻塞I/O：** 传统的阻塞式IO，线程在执行IO操作时，如果IO操作没有完成，那么线程就会一直被阻塞。非阻塞IO，一个线程可以同时处理多个I/O操作，而不会因为其中某个I/O操作的阻塞而影响其他操作的执行。

#### 分布式锁

使用SETNX命令来实现分布式锁，key可以使用线程ID作为标识

分布式锁

- 可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。
- 这把锁要是一把可重入锁（避免死锁）
- 这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）
- 这把锁最好是一把公平锁（根据业务需求考虑要不要这条）
- 有高可用的获取锁和释放锁功能
- 获取锁和释放锁的性能要好

#### **缓存穿透**

**请求的 key在缓存中查不到，导致请求到了数据库，减低系统性能。**

**解决方案**：

* 缓存中**将不存在的数据设置为特殊值，如null，避免频繁访问数据库**
* **对请求进行过滤，判断请求是否合法**。
* 最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。

#### 缓存雪崩（**Cache Avalanche）

**某个时间点，缓存中的大量数据同时失效，导致大量请求直接访问数据库，产生瞬时的高并发，可能引起数据库压力过大。**

**解决方案**：

- 使用**不同的过期时间**，**避免**所有缓存**同时失效**。
- 引入缓存**预热**机制，**提前加载热点数据到缓存**。
- 使用**分布式锁**，保证在缓存失效时只有一个请求去更新缓存。

#### **缓存击穿**（Cache Breakdown）

**某些热点数据在缓存失效的瞬间，大量请求直接访问数据库，导致数据库压力激增。**

**解决方案**：

- 在失效的时候，通过**加锁**或者其他手段，防止并发请求同时访问数据库。
- 使用队列或**限流**等机制，控制瞬时的高并发请求。

#### redis的发布订阅（pub/sub）模式介绍一下？

答：发布用的是publish命令，订阅用的是subscribe命令，订阅的话可以订阅多个频道。pubscribe

补充：

```
#发布消息
本机:0>publish todaynews  "新中国成立了"
"0" 代表没人订阅

#打开另外一个客户端，去订阅
格式：SUBSCRIBE channel [channel ...]
本机: 0>subscribe todaynews
Switch to Pub/ Sub mode. Close console tab to stop 1 isten for messages.
1) " subscribe " 表示类型
2)”todaynews'    表示订阅的频道
3)"1”            订阅的数量

#退订
格式： UNSUBSCRIBE channel [channel ...]
本机:0>unsubscribe todaynews
 1)  "unsubscribe"
 2)  "todaynews"
 3)  "0"

```

#### redis和数据库数据不一致怎么解决，怎么样才能保证缓存一致性

答：

更新数据：先更新数据库，再更新缓存。更新数据库和更新缓存是2个动作，不是原子操作，都存在失败的风险，如果先更新缓存的话，如果在更新数据库的时候失败了，那么下次取数据的时候就会从缓存里面取，这时候取到的数据就是不对的。

读取数据：先读缓存，读取不到就读数据库，然后再把到数据写到缓存中。

#### 什么样的数据适合放入缓存

1. **频繁被访问**：缓存适合存储那些被系统频繁访问的数据，例如热点数据或常用数据。这样可以减轻数据库的压力，提高系统性能。
2. **读多写少**：如果数据读取的次数远远大于写入的次数，将这部分读多写少的数据放入缓存可以有效提高系统的读取速度。
3. **需要快速响应的数据**：对于需要快速响应的数据，例如页面渲染所需的数据或频繁使用的配置信息，放入缓存可以降低数据获取的延迟。
4. **数据相对稳定**：数据相对稳定，不经常发生变化，避免缓存中的数据频繁失效导致缓存穿透等问题。
5. **数据量适中**：适合缓存的数据量不宜过大，否则可能导致缓存空间不足，而过小则可能导致缓存效果不显著。