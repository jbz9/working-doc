#### 简介

https://www.redis.com.cn/redis-interview-questions.html

https://redisson.org/ 分布式锁

https://www.cnblogs.com/xuanyuan/p/13665170.html

redis是一个非关系型数据库，不过和传统的数据库不同，它的数据是存在内存当中的，所以读写速度非常快，一般用于缓存。它的存储方式是key、value键值对，键的类型只能是字符串，value的类型可以是**字符串、列表、散列Hash、有序集合、无序集合**

| 数据类型 | 可以存储的值           | 操作                                                         |
| -------- | ---------------------- | ------------------------------------------------------------ |
| STRING   | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 |
| LIST     | 列表                   | 从两端压入或者弹出元素 对单个或者多个元素进行修剪， 只保留一个范围内的元素 |
| SET      | 无序集合               | 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 |
| HASH     | 包含键值对的无序散列表 | 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 |
| ZSET     | 有序集合               | 添加、获取、删除元素 根据分值范围或者成员来获取元素 计算一个键的排名 |

#### 缓存简介

参考：https://juejin.im/post/6883650497975320589

[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%BC%93%E5%AD%98.md#%E7%BC%93%E5%AD%98](https://github.com/CyC2018/CS-Notes/blob/master/notes/缓存.md#缓存)

本地缓存、分布式缓存、多级缓存

* 本地缓存：缓存在JVM中，一般用Map实现，缺点是内存比较小，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。优点是,没有远程交互，性能比较好
* 分布式缓存：一般用redis，优点是：容易水平拓展，缺点是：多了远程交互，性能不如本地缓存
* 多级缓存：使用本地+分布式缓存，本地缓存放访问频率最高的数据，其他的热点数据放在分布式缓存中。

##### 缓存特征

**命中率**

请求能够从缓存中拿到数据，就是命中，缓存命中率越高，即缓存的效率越高

**最大空间**

缓存往往存在于内存当中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。

**淘汰策略**

8种内存淘汰策略，

都是使用内存来保存数据，由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。

淘汰最早的数据、淘汰最近很少使用的数据、淘汰最近使用频率的最低的数据

* FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。
* LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。
* LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。

**本地缓存**
使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。

**分布式缓存**
使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。

相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，**而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。**

**缓存一致性**

缓存一致性要求数据更新的同时缓存数据也能够实时更新。

解决方案：

- 在数据更新的同时立即去更新缓存；
- 在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。

**计数器**

可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

**缓存穿透**

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。

解决：

* 在数据库返回为null时，给redis新增一条数据，这样请求就不会到数据库了。
* 对这类请求进行过滤
* 最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。

**缓存雪崩**

这一次是一大批数据几乎同时过了有效期，

缓存雪崩就是我们在设置缓存数据时,设置的有效期相同,导致在同一时刻,大部分的缓存同时到期,这时候,所有的请求在redis中拿不到数据,都去访问数据库,数据库就受到了所有请求的压力,在高并发的情况下,成千上万个请求同时到达数据库,导致数据库崩溃。

解决：设置不同缓存到期时间

**缓存击穿**

缓存击穿像是缓存穿透和缓存雪崩的结合,意思是一个数据太热点,在高并发情况下,这个数据的缓存到期,成千上万的请求又绕过了redis直接打到了数据库,导致数据库的崩溃

解决：分布式锁，分布式锁就是一把限制人流的锁,像一个保安一样,守护着进入数据库的入口.对于抢到锁的那一个请求才会放行,后面的请求只能排队.等待抢到锁的人进入数据库将数据从数据库取出来存到缓存中,才允许后面的人进来访问,此时访问的时候,前面的人已经将数据存放到缓存中,则后面的人就可以从Redis中取数据而不是直接访问数据库了

#### 内存过期策略和内存淘汰机制

内存过期策略是处理过期的数据，内存淘汰策略是处理内存不够的时候，处理数据的策略

##### 内存过期策略

主要作用：在缓存过期之后，及时的将数据从内存中删除，以减少内存的占用

分为：定期、定时、惰性策略

**定时删除**：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作

- **优点：**对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放国期间所占用的内存
- **缺点：**对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量

**惰性删除**：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键

- **优点：**对cpu时间友好，在每次从键空间获取键时进行过期键检查并是否删除，删除目标也仅限当前处理的键，这个策略不会在其他无关的删除任务上花费任何cpu时间。
- **缺点：**对内存不友好，过期键过期也可能不会被删除，导致所占的内存也不会释放。甚至可能会出现内存泄露的现象，当存在很多过期键，而这些过期键又没有被访问到，这会可能导致它们会一直保存在内存中，造成内存泄露。

**定期删除**：每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

* 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

* 定时删除策略有效地减少了因为过期键带来的内存浪费。

##### 内存淘汰机制

是针对内存不足时，redis的一种处理机制，例如目前内存已经满了，即服务器内存1G，现在redis内存已经占用了1G，没有内存了

1. **noeviction（不淘汰策略）：**
   - 当内存不足以容纳新写入数据时，新的写入操作会报错。
   - 这是默认的淘汰策略。
2. **allkeys-lru（最近最少使用，全体键）：**
   - 根据键最近被使用的频率进行淘汰。
   - 对所有键进行考虑，选择最近最少使用的键进行淘汰。
3. **volatile-lru（最近最少使用，过期键）：**
   - 仅对设置了过期时间（TTL）的键进行最近最少使用淘汰。
4. **allkeys-random（随机淘汰，全体键）：**
   - 从所有键中随机选择一个进行淘汰。
5. **volatile-random（随机淘汰，过期键）：**
   - 仅对设置了过期时间（TTL）的键进行随机淘汰。
6. **volatile-ttl（根据 TTL 进行淘汰，过期键）：**
   - 对设置了过期时间（TTL）的键，根据 TTL 的值进行淘汰，TTL 越小越容易被淘汰。
7. **volatile-lfu（最不经常使用，过期键）：**
   - 对设置了过期时间（TTL）的键，根据 LFU（Least Frequently Used）算法进行淘汰。
8. **allkeys-lfu（最不经常使用，全体键）：**
   - 根据 LFU 算法对所有键进行淘汰，不考虑过期时间。





#### 常见问题

###### 1、为什么要用redis

主要是解决项目的并发和性能问题。

优点：

速度快：每秒大概可以执行10万次的读写操作

支持的数据类型比较多：字符串、列表、集合、排序集合、散列

基础数据结构：String字符串、list列表、set集合、hash字典、zset有序集合 5种

* 字符串：是动态字符串，我们可以修改

* 列表：类似Java的linkedList，是双向链表结构，插入、删除很快，查询慢
* hash：类型Java的HashMap，是数组+链表结构
* 集合：类似HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL
* 有序列表：类似于 Java 中 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。

###### 2、分布式下缓存和数据库一致性问题

##### 3、Redis6.0之前为什么一直不使用多线程？

 Redis主要受限于内存和网络，CPU一般不会成为性能瓶颈，使用单线程，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。Redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。

##### 4、Redis6.0为什么要引入多线程呢？

Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000到100,000 QPS（一台服务器每秒能够响应的查询次数），这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。每秒可以处理50万请求，

但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等。

从Redis自身角度来说，因为读写网络的read/write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:

• 提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式
• 使用多线程充分利用多核，典型的实现比如 Memcached。

协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，redis支持多线程主要就是两个原因：

• 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核
• 多线程任务可以分摊 Redis 同步 IO 读写负荷

##### 5、Redis 有哪些架构模式？讲讲各自的特点

单节点

特点：简单

问题：

1、内存容量有限 2、处理能力有限 3、无法高可用。

**主从复制**

读写分离，主节点写入数据，从节点从主节点复制数据，数据读取也在从节点读取。

特点：

1、master/slave 角色

2、master/slave 数据相同

3、降低 master 读压力在转交从库

问题：

无法保证高可用

没有解决 master 写的压力

**哨兵模式**

Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：

监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。

提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。

自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。

特点：

1、保证高可用

2、监控各个节点

3、自动故障迁移

缺点：主从模式，切换需要时间丢数据

没有解决 master 写的压力。

##### 6、适用缓存可能出现的问题

数据不一致的问题、缓存穿透、缓存雪崩

**7、redis的过期策略和内存淘汰策略**

https://segmentfault.com/a/1190000023060522

**内存淘汰策略**

内存过期策略主要的作用就是，在缓存过期之后，能够将缓存从内存中删除，以减少内存的无效暂用，达到释放内存的目的。



**KEY的过期策略**

* 定时策略：在创建key的时候，去创建定时器，在Key过期的时候，就去内存里把key删了
* 惰性策略：Key到期了也不删除，而是每次去访问的时候，去查一下Key有没有过期，过期了，就删掉，返回null
* 定期策略：设置一个定期时间，然后到了时间就去检查key，过期了就去删除，没有过期就不管。

**持久化策略**

持久化存储，指的是将内存的缓存永久存在磁盘中。也就是说我们的AOF和RDB持久化存储方式。

* RDB持久化：持久化key之前，会检查是否过期，过期的key不进入RDB文件。数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）
* AOF持久化：

内存淘汰机制：

内存淘汰机制针对是内存不足的情况下的一种Redis处理机制。例如，当前的Redis存储已经超过内存限制了，然而我们的业务还在继续往Redis里面追加缓存内容，这时候Redis的淘汰机制就起到作用了。

```c
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。

allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）。

volatile-lfu：当内存不足以容纳新写入数据时，在过期密集的键中，使用LFU算法进行删除key。

allkeys-lfu：当内存不足以容纳新写入数据时，使用LFU算法移除所有的key。

volatile-random：当内存不足以容纳新写入数据时，在设置了过期的键中，随机删除一个key。

allkeys-random：当内存不足以容纳新写入数据时，随机删除一个或者多个key。

volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。

```

##### **7、 Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)**

通过持久化将内存中数据持久化到磁盘，支持快照RDB和AOF2种方式.

**快照（snapshotting）持久化（RDB）**

Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。

**AOF（append-only file）持久化**

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。

##### 8、Redis 为什么快

QPS每秒10万(每秒查询/请求数)



1. **内存存储：** Redis将数据存储在内存中，读写速度极快。因为它**避免了磁盘I/O的开销，相比传统数据库的磁盘存储，内存存储能够提供更低的访问延迟。**
2. **单线程模型**：避免多线程之间的锁竞争，降低了线程切换的CPU开销。
3. **非阻塞I/O：** 传统的阻塞式IO，线程在执行IO操作时，如果IO操作没有完成，那么线程就会一直被阻塞。非阻塞IO，一个线程可以同时处理多个I/O操作，而不会因为其中某个I/O操作的阻塞而影响其他操作的执行。

**阻塞、非阻塞**
阻塞与非阻塞描述的是调用者的。以调用之后，需不需要等待为判断依据，需要等待返回结果的是阻塞式，不需要等待返回结果是非阻塞式。

如A调用B：

如果是阻塞，A在发出调用后，要一直等待，等着B返回结果。

如果是非阻塞，A在发出调用后，不需要等待，可以去做自己的事情。

**同步，异步 和 阻塞，非阻塞之间的区别**

[同步、异步](http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/synchronized-vs-asynchronization)，是描述被调用方的。

阻塞，非阻塞，是描述调用方的。

同步不一定阻塞，异步也不一定非阻塞。没有必然关系。

**非阻塞IO模型**

当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。

所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。

典型的非阻塞IO模型一般如下：

```java
while(true){
    data = socket.read();
    if(data!= error){
        处理数据
        break;
    }
}
```

但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。

**IO复用模型**

##### 9、redis实现分布式锁

锁

- 在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量。
- 而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁。

分布式场景

`此处主要指集群模式下，多个相同服务同时开启.`

分布式锁

- 可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。
- 这把锁要是一把可重入锁（避免死锁）
- 这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）
- 这把锁最好是一把公平锁（根据业务需求考虑要不要这条）
- 有高可用的获取锁和释放锁功能
- 获取锁和释放锁的性能要好

