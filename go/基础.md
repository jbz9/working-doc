# GoLang

### 常见问题

#### 协程、线程、进程的区别

**进程**：操作系统资源分配的基本单位

**线程**：是CPU调度的基本单位，一个进行可以拥有多个线程，

**协程**：是用户级的线程，对于进程和线程，它们都是内核进行调度，有CPU时间片概念，调度都是抢占式的；

而协程对内核是透明的，内核是不知道协程的存在的，它是有用户程序去控制的，只能使用**协作式调度**，也就是只有协程自己让出资源，其它协程才能执行。

同时协程占用资源更小，只有2kb，而线程的话需要8Mb；而且线程切换，需要由用户态切换内核态，涉及到时钟中断、系统调度，而协程没有这些。

#### channel和goroutine

#### 内存模型

#### Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？

还可以使用Channel 通道进行共享变量读写操作

#### 无缓冲 Chan 的发送和接收是否同步?

```
ch := make(chan int)    无缓冲的channel由于没有缓冲发送和接收，需要同步.
ch := make(chan int, 2) 有缓冲channel，不需要发送和接收操作同步，会有阻塞
```

####  Golang 中常用的并发模型？

##### 1.1 通过channel通知

##### 1.2 通过WaitGroup

##### 1.3 通过Context上下文

#### GMP调度模型

[GMP模型 — 深入Go语言之旅 (cyub.vip)](https://go.cyub.vip/gmp/gmp-model.html)

**G-M-P分别代表：**

- **G - Goroutine，Go协程**，是参与调度与执行的最小单位
- **M - Machine，内核线程**，Machine：机器
- **P - Processor，是逻辑处理器**，P关联了的本地可运行G的队列(也称为LRQ)，最多可存放256个G。

Goroutine = Golang + Coroutine。Coroutine是**golang实现的协程**

- 相比线程，其启动的代价很小，以很小栈空间启动（2Kb左右）
- 能够动态地伸缩栈的大小，最大可以支持到Gb级别
- 工作在用户态，切换成很小
- 与线程关系是n:m，即N线程可以调度M个协程

##### 为什么线程和协程不是1:n

如果是1：n，如果有一个协程被阻塞了，那可能会影响下一个协程的执行，协程是轮询去执行的

线程创建、管理、调度等采用的方式称为线程模型。线程模型一般分为以下三种：

- 内核级线程(Kernel Level Thread)模型，**用户线程与内核线程是一对一关系（1 : 1）**
- 用户级线程(User Level Thread)模型，**用户线程与内核线程KSE是多对一关系（N : 1）**
- 两级线程模型，也称混合型线程模型

##### 线程模型

G 的数量：

理论上没有数量上限限制的。查看当前G的数量可以使用`runtime. NumGoroutine()`

P 的数量：

由启动时环境变量 `$GOMAXPROCS` 或者是由`runtime.GOMAXPROCS()` 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。

M 的数量:

go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。 runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量 一个 M 阻塞了，会创建新的 M。M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。

##### **work stealing 偷取机制**

**hand off切换机制**

如果G因为系统调用，造成了阻塞，那么它会阻塞对应的M，此时M和P会进行解绑,P会寻找一个空闲的M，若没有空闲的M就会新建一个M，去接管P；

