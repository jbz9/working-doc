### 限流

使用令牌桶算法。实现：guava的RateLimiter

① 我们需要使用一个线程以固定的速度向令牌桶（队列）里源源不断的放入令牌

② 当我们请求来的时候，我们需要先向令牌桶中获取一个令牌，拿到的令牌再执行请求，如果拿不到，就拒绝请求

它的核心是令牌桶的令牌是有限的，如果桶满了，就不会再向桶里放入令牌。如果在一段时间内，请求的速度大于令牌的放入的速度，那么桶里面很快就没有令牌了，这样服务器就会拒绝一部分请求，从而达到服务降级的目的。

<img src="https://cdn.jsdelivr.net/gh/jbz9/picture@main/image/16528557451791652855744331.png" style="zoom:50%;" />

### 缓存一致性

问题：先更新数据库，再更新缓存。并发情况下可能出现缓存和数据库不一致的问题。

原因：线程1更新缓存慢了

![](https://cdn.jsdelivr.net/gh/jbz9/picture@main/image/16528703739771652870373817.png)



问题：先删缓存，再写库。并发情况下可能出现缓存和数据库不一致的问题。





解决方案：

更新缓存时:  *Cache Aside Pattern（先更新库，再删除缓存）*+延迟双删 的策略



要保住数据库和缓存的强一致性，最好的方式是**分布式锁**，但是这样并发性能就上不去。