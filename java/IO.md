# IO

IO：Input和output的缩写

fd：file descriptor 文件描述符，是一个从0开始的无符号整数，用来管理Linux中的文件，包括socket套接字。

IO操作：read、write

## IO模型



### 阻塞IO

用户线程在内核操作IO是阻塞的

①首先用户线程发起read请求到达内核

②然后内核等待数据返回，数据返回之后，将数据拷贝给用户线程，完成一次IO操作

缺点：整个过程都是阻塞式的，用户线程需要等待内核数据返回，这样对CPU的利用效率不高

### 非阻塞IO

用户线程在请求读取内核之后，会立即返回，不再阻塞用户线程，同时内核也会去准备数据，然后用户线程不同轮询内核，询问数据是否准备好了，如果有数据了，就copy到用户线程

① 用户线程请求内核，然后立即返回

② 内核这边收到请求之后，准备数据

③ 用户线程没有拿到数据，会继续轮询内核，知道内核中数据准备完成，然后进行copy到用户线程

缺点：不断轮询，消耗资源，作用不大

### IO多路复用

思路：通过一个线程去监控多个FD（socket），当某个FD可用了，监控线程就会得到通知,然后再去进行IO读取操作。

监控PD的方式、通知有三种：

* select

* poll

* epoll

差别：select和poll方式只能通知到用户线程，有fd就绪了，但是具体不知道是哪个，需要用户进程遍历FD确认

epoll是能够知道是哪个fd就绪了，会把就绪的FD告诉用户线程

select、poll、epoll的区别

|                            | select                                               | poll                                               | epoll                                                        |
| -------------------------- | ---------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 底层数据结构               | **数组**存储文件描述符                               | **链表**存储文件描述符                             | **红黑树**存储监控的文件描述符，**双链表**存储就绪的文件描述符 |
| 如何从fd数据中获取就绪的fd | 遍历fd_set                                           | 遍历链表                                           | 回调                                                         |
| 时间复杂度                 | 获得就绪的文件描述符需要遍历fd数组，O(n)             | 获得就绪的文件描述符需要遍历fd链表，O(n)           | 当有就绪事件时，系统注册的回调函数就会被调用，将就绪的fd放入到就绪链表中。O(1) |
| FD数据拷贝                 | 每次调用select，需要将fd数据从用户空间拷贝到内核空间 | 每次调用poll，需要将fd数据从用户空间拷贝到内核空间 | 使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间 |
| 最大连接数                 | 有限制，一般为1024                                   | 无限制                                             | 无限制                                                       |