# IO

IO：Input和output的缩写

fd：file descriptor 文件描述符，是一个从0开始的无符号整数，用来管理Linux中的文件，包括socket套接字。

IO操作：read、write

## IO分类

### 阻塞IO

用户线程在内核操作IO是阻塞的

①首先用户线程发起read请求到达内核

②然后内核等待数据返回，数据返回之后，将数据拷贝给用户线程，完成一次IO操作

缺点：整个过程都是阻塞式的，用户线程需要等待内核数据返回，这样对CPU的利用效率不高

### 非阻塞IO

用户线程在请求读取内核之后，会立即返回，不再阻塞用户线程，同时内核也会去准备数据，然后用户线程不同轮询内核，询问数据是否准备好了，如果有数据了，就copy到用户线程

① 用户线程请求内核，然后立即返回

② 内核这边收到请求之后，准备数据

③ 用户线程没有拿到数据，会继续轮询内核，知道内核中数据准备完成，然后进行copy到用户线程

缺点：不断轮询，消耗资源，作用不大

### IO多路复用

思路：通过一个线程去监控多个FD（socket），当某个FD可用了，监控线程就会得到通知,然后再去进行IO读取操作。

监控PD的方式、通知有三种：

* select

* poll

* epoll

差别：select和poll方式只能通知到用户线程，有fd就绪了，但是具体不知道是哪个，需要用户进程遍历FD确认

epoll是能够知道是哪个fd就绪了，会把就绪的FD告诉用户线程

select、poll、epoll的区别

|                            | select                                               | poll                                               | epoll                                                        |
| -------------------------- | ---------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 底层数据结构               | **数组**存储文件描述符                               | **链表**存储文件描述符                             | **红黑树**存储监控的文件描述符，**双链表**存储就绪的文件描述符 |
| 如何从fd数据中获取就绪的fd | 遍历fd_set                                           | 遍历链表                                           | 回调                                                         |
| 时间复杂度                 | 获得就绪的文件描述符需要遍历fd数组，O(n)             | 获得就绪的文件描述符需要遍历fd链表，O(n)           | 当有就绪事件时，系统注册的回调函数就会被调用，将就绪的fd放入到就绪链表中。O(1) |
| FD数据拷贝                 | 每次调用select，需要将fd数据从用户空间拷贝到内核空间 | 每次调用poll，需要将fd数据从用户空间拷贝到内核空间 | 使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间 |
| 最大连接数                 | 有限制，一般为1024                                   | 无限制                                             | 无限制                                                       |

### 阻塞和非阻塞

阻塞和非阻塞是针对`应用程序`的，当我们应用程序去请求操作系统去执行IO操作，如果IO资源没有就绪，此时我们的程序有2种方式，一种是等待IO，这就是阻塞式的，一种是不等待IO返回，而是不断去轮询IO有有没就绪，这是非阻塞的。关键在于**线程是否等待IO返回**



### 同步和非同步

## IO模型

### BIO

Blocking IO，阻塞IO，当线程发送一个IO请求的时候，都需要等待IO返回

缺点：

每一个请求都需要一个线程去处理，不适合并发量大的场景

### NIO

Non Blocking IO，非阻塞IO,一个线程可以处理多个请求，也就是线程不需要去等待IO返回，而是使用轮询的方式去查询IO数据是否就绪了。

Java里面的NIO是NIO模型+多路复用，也就是new io，它主要有3个组件：selector、channel、buffer。

selector：用来分发事件，channel：用来双向通讯，buffer：是和channel进行交互，Channel 是通过 Buffer 来读写数据的。

①客户端请求通过**Channel**注册到selector上，selector去轮询socket检查

缺点：

不断轮询，消耗资源。

适合：

连接数目多，并且连接比较短的场景

#### NIO和BIO的区别

NIO是面向缓冲区的；BIO是面向流的。

NIO是非阻塞的，BIO是阻塞的

##### Buffer

是一个内存块，有3个属性，容量capacity、当前已经读取的自己数position、还能够读取的字节数limit

##### Channel

* FileChannel 从文件中读写数据
* SocketChannel  通过 TCP 读写网络中数据

### AIO

Asynchronous IO，异步非阻塞IO，线程在请求IO的时候，不会阻塞，当IO数据准备就绪的时候，会通知线程,IO准备就绪了。